# 客户端、服务器、同构
-   客户端渲染：页面在 JavaScript，CSS 等资源文件加载完毕后开始渲染，路由为客户端路由，也就是我们经常谈到的 SPA（Single Page Application）。  
-   服务器端渲染：页面由服务端直接返回给浏览器，路由为服务端路由，URL 的变更会刷新页面，原理与 ASP，PHP 等传统后端框架类似。  
-   同构：即编写的 JavaScript 代码可同时运行于浏览器及 Node.js 两套环境中，用服务端渲染来提升首屏的加载速度，首屏之后的路由由客户端控制，即在用户到达首屏后，整个应用仍是一个 SPA。  

## 同构
不论是客户端渲染，还是服务端渲染，都有着其明显的缺陷，而同构显然是结合了二者优点之后的一种更好的解决方案。  

## 总体架构
![](https://github.com/lyyh/FELearningNotes/blob/master/public/images/part%201/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9E%B6%E6%9E%84.jpg) 

### 服务器端渲染
1. 服务端预先获取编译好的客户端代码及其他资源。  
2. 在服务端接收到用户的 HTTP 请求后，触发服务端的路由分发，将当前请求送至服务端渲染模块处理。  
3. 服务端渲染模块根据当前请求的 URL 初始化 memory history 及 redux store。  
4. 根据路由获取渲染当前页面所需要的异步请求（thunk）并获取数据。
5. 调用 renderToString 方法渲染 HTML 内容并将已包含数据的 redux store 塞入 HTML 中，供客户端渲染时使用。
6. 此时，客户端将直接收到服务端返回的已渲染完毕的当前页面并开始同步加载客户端 JavaScript，CSS，图片等其他资源。  
7. 之后的流程与客户端渲染完全相同，客户端初始化 redux store，路由找到当前页面的组件，触发组件的生命周期函数，再次获取数据并渲染。唯一不同的是 redux store 的初始状态将由服务端在 HTML 中塞入的数据提供，以保证客户端渲染时可以得到与服务端渲染相同的结果。


## 客户端与服务器的构建脚本不同
因为运行环境与渲染目的的不同，共用一套代码的客户端与服务端在构建方面有着许多的不同之处。

### 入口(entry)不同
客户端的入口为 ReactDOM.render 所在的文件，即将 react 组件挂载在 DOM 节点上。而服务端因为没有 DOM 的存在，只需要拿到将要渲染的 react 组件即可。

### 出口(output)不同
为了最大程度地提升用户体验，在客户端渲染时我们将根据路由对代码进行分拆，但在服务端渲染时，确定某段代码与当前路由之间的关系是一件非常繁琐的事情，所以我们选择将所有客户端代码打包成一个完整的 js 文件供服务端使用。

### 使用的插件不同
与客户端不同，除去 JavaScript 之外，服务端并不需要任何其他的资源，如 HTML 及 CSS 等，所以在构建服务端 JavaScript 时，诸如 HtmlWebpackPlugin 等客户端所特有的插件就可以省去了

### 数据获取的方式不同
异步数据获取一直都是服务端渲染做得不够优雅的一个地方，其主要的问题在于无法直接复用客户端的数据获取方法。如在 redux 的前提下，服务端没有办法像客户端那样直接在组件的componentDidMount 中调用 action 去获取数据。

## 服务器端渲染还能做些什么呢
SEO、首屏加载，服务器渲染服务
### 初始化应用状态
除去获取当前页面的数据，在做了同构之后，客户端还可以将获取应用全局状态的一些请求也交给服务端去做，如获取当前时区，语言，设备信息，用户等通用的全局数据。这样客户端在初始化 redux store 时就可以直接获取到上述数据，从而加快其他页面的渲染速度，同时在分离了这部分业务逻辑到服务端之后，客户端的业务逻辑也将变得更为简单与清晰。当然，如果你想做一个纯粹的 Universal App，也可以把初始化应用状态封装成一个方法，让服务端与客户端都可以自由地去调用它。

### 更早的路由处理
相较于客户端，服务端可以更早地对当前 URL 进行一些业务逻辑上的判断。比如 404 时，服务端可以直接将另一个 error.html 的模板直接发送至客户端，用户也就可以在第一时间收到相应的反馈，而不需要等到所有 JavaScript 等加载完毕之后，才看到由客户端渲染的 404 页面。又或是 302 等其他一些特殊情况，服务端都可以更早地做出应对。


### 其他
有了服务端渲染这一层后，服务端还可以帮助客户端向 Cookie 里注入一些后端 API 中没有的数据，甚至做一些接口聚合，数据格式化的工作。这时，我们所写的 Node.js 服务端就不再是一个单纯的渲染服务了，而是进化为了一个 Node.js 中间层，可以帮助客户端完成许多在客户端做不到或很难做到的事情。

### 要不要做同构
同构和服务器渲染最大的性能瓶颈：性能以及容量    
在用户规模大到一定程度之后，客户端渲染本身就是一个完美的分布式系统，我们可以充分地利用用户的电脑去运行 JavaScript 中那些复杂的运算，而服务端渲染却将这些工作全部揽了回来并加到了网站自己的服务器上。  

适用与不适用
-   前端做大量的计算（如包含大量的图表或仪表盘的页面等）且用户量非常巨大的应用，却非常适用于大部分的内容展示型网站，  
-   以知乎为例，服务端渲染与客户端渲染的成本几乎是相同的，重点都在于获取用户时间线上的数据，这时多页面的服务端渲染可以很好地加快首屏渲染的速度，又因为运行 renderToString 时的计算量并不大，即使用户量很大，也仍然是一件值得去做的事情。

## 小结
-   前端开发介入到服务器，一是服务器端渲染，二是对接口做一些代理和整合
-   一个软件之所以复杂，很多时候就是因为分层架构没有做好，导致其中某一个模块过于臃肿，集中了大部分的业务复杂度，而其他模块又根本帮不上忙。所以想做好前端数据层的工作，只把眼光局限在客户端是远远不够的，将业务复杂度均分到客户端及服务端，并让两方分别承担各自适合的工作，可能会是一种更好的解法。  

## 参考
[服务端渲染与 Universal React App](https://zhuanlan.zhihu.com/p/30580569)