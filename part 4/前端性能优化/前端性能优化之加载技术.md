# 前端性能优化之加载技术
## 优化背景
从解析HTML内容，构造DOM节点再到DOM元素布局定位最后再绘制DOM元素的这样一个过程  

在页面渲染的这样一个过程中，有一个关键点是如果在解析内容的过程中遇到了脚本标签，如：<script src="example.js"></script>，浏览器就会暂停内容的解析，转而开始下载脚本。并且只有等脚本下载完并执行结束后，渲染引擎才会继续解析。那么这样一来，页面显示的时间必然会被延长。因此我们需要优化的点就是尽可能地让页面更早地被渲染出来。  

## 脚本加载的优化
1. 脚本放在HTML末尾   
2. 动态加载脚本  
3. 异步加载脚本  

### 动态加载
所谓动态加载脚本就是利用javascript代码来加载脚本，通常是手工创建script元素，然后等到HTML文档解析完毕后插入到文档中去。这样就可以很好地控制脚本加载的时机，从而避免阻塞问题。   
```
function loadJS(src) {
  const script = document.createElement('script');
  script.src = src;
  document.getElementsByTagName('head')[0].appendChild(script);
}
loadJS('http://example.com/scq000.js');
```

### 异步加载
利用脚本的async和defer属性就可以实现这种需求：  
```
<script type="text/javascript" src="./a.js" async></script>  
<script type="text/javascript" src="./b.js" defer></script>
```
但是使用async属性的脚本执行顺序是不能得到保证的。而使用defer属性的脚本执行顺序可以得到保证  
1. defer属性是在html文档解析完成后，DOMContentLoaded事件之前就会执行js。  
2. async一旦加载完js后就会马上执行，最迟不超过window.onload事件。  

defer/async 都是异步加载，只不过执行顺序不同。如果脚本没有操作DOM等元素，或者与DOM时候加载完成无关，直接使用async脚本就好。如果需要DOM，就只能使用defer了。

### 异步加载遇到的依赖问题
处理加载过程中脚本依赖的问题，AMD规范的RequireJS,甚至有采用了hack技术（通过欺骗浏览器下载但不执行脚本)的labjs（已过时)。或者使用promised一种处理异步的强有力工具。使用promised技术来实现处理异步脚本加载过程中的依赖问题。  

```
// 执行脚本
function exec(src) {
    const script = document.createElement('script');
    script.src = src;

      // 返回一个独立的promise
    return new Promise((resolve, reject) => {
        var done = false;
        // onreadystatechange 兼容性处理
        script.onload = script.onreadystatechange = () => {
            if (!done && (!script.readyState || script.readyState === "loaded" || script.readyState === "complete")) {
              done = true;

              // 避免内存泄漏
              script.onload = script.onreadystatechange = null;
              resolve(script);
            }
        }

        script.onerror = reject;
        document.getElementsByTagName('head')[0].appendChild(script);
    });
}

function asyncLoadJS(dependencies) {
    return Promise.all(dependencies.map(exec));
}

asyncLoadJS(['https://code.jquery.com/jquery-2.2.1.js', 'https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js']).then(() => console.log('all done'));
```

## 懒加载(lazyload)
懒加载是一种按需加载的方式，也通常被称为延迟加载。主要思想是通过延迟相关资源的加载，从而提高页面的加载和响应速度。在这里主要介绍两种实现懒加载的技术：虚拟代理技术以及惰性初始化技术。  
### 虚拟代理加载
所谓虚拟代理加载，即为真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种loading的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。
```
// 页面中的图片url事先先存在其data-src属性上
const lazyLoadImg = function() {
  const images = document.getElementsByTagName('img');
  for(let i = 0; i < images.length; i++) {
      if(images[i].getAttribute('data-src')) {
          images[i].setAttribute('src', images[i].getAttribute('data-src'));
          images[i].onload = () => images[i].removeAttribute('data-src');
      }
  }
}
```

### 惰性初始化加载




