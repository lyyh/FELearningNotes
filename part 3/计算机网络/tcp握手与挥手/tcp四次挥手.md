# tcp四次挥手
### 为什么需要四次挥手
当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
### 四次挥手
-   关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送。客户端进入终止等待状态 FIN-WAIT-1。然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u  
-   服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。服务器进入close-wait状态。客户端到服务器的连接就释放了。此时进入半关闭状态，即客户端不能发送给服务器，服务器可以发送给客户端。
-   当服务器没有数据发送给客户端的时候，同时TCP释放连接，发送给A连接释放报文，并等待确认，。关闭服务器到客户端的连接：也是发送一个FIN给客户端。  
-   客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。发送确认之后，进入time-wait状态。此时TCP还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到close状态。  

### 关闭与释放连接
-   第一次A发送FIN到B,A到B不能发送数据，但还能接收数据，第二次B返回确认之后，释放A到B的连接
-   第三次B发送FIN到A，B到A不能发送数据，但还能接收数据，第四次A返回确认，A进入time-wait状态，注意此时TCP还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到close状态。 
-   B结束TCP连接的时间比A早一点，因为B收到确认就断开连接了，而A还得等待2MSL 

### MSL
MSL即Maximum Segment Lifetime，也就是最大报文生存时间，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间”。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。 

### 为什么要等待2MSL
防止最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。
-   ①、为了保证A发送的最后一个ACK报文段能够到达B。即最后这个确认报文段很有可能丢失，那么B会超时重传，然后A再一次确认，同时启动2MSL计时器，如此下去。如果没有等待时间，发送完确认报文段就立即释放连接的话，B就无法重传了（连接已被释放，任何数据都不能出传了），因而也就收不到确认，就无法按照步骤进入CLOSE状态，即必须收到确认才能close。  
-   、防止“已失效的连接请求报文段”出现在连接中。经过2MSL，那些在这个连接持续的时间内，产生的所有报文段就可以都从网络中消失。即在这个连接释放的过程中会有一些无效的报文段滞留在楼阁结点，但是呢，经过2MSL这些无效报文段就肯定可以发送到目的地，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文段了。  

### 为什么是四次挥手
-   TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。
-   当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。
-   发送了FIN只是表示这端不能继续发送数据(应用层不能再调用send发送)，但是还可以接收数据
-   收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据，比如：如主机A收到主机B的FIN断开TCP连接请求，只是表示主机B已经发送完数据，主机A收到FIN后作出应答，并终止这个方向的数据传输，此时处于半关闭状态。但是主机A仍然可以发送数据的，只有当主机A发送完数据并发送FIN给主机B时，主机B才停止这个方向的数据传输，并关闭TCP连接。  

### 原则
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接  

### 深入理解TCP连接释放详细过程
-   第一阶段：客户机发送完数据之后，向服务器发送一个FIN数据段，序列号为i；  
    1.服务器收到FIN(i)后，返回确认段ACK，序列号为i+1，关闭服务器读通道；  
    2.客户机收到ACK(i+1)后，关闭客户机写通道；
   （此时，客户机仍能通过读通道读取服务器的数据，服务器仍能通过写通道写数据）  
-   第二阶段：服务器发送完数据之后，向客户机发送一个FIN数据段，序列号为j；  
    3.客户机收到FIN(j)后，返回确认段ACK，序列号为j+1，关闭客户机读通道；  
    4.服务器收到ACK(j+1)后，关闭服务器写通道。

### 关闭数据传输与返回ACK是否冲突
-   发送数据是特指上层协议的，即不能发送数据报
-   本层tcp还是可以发送的。 

### 参考资料
[TCP三次握手和四次挥手](http://www.cnblogs.com/Jessy/p/3535612.html)  
[TCP建立连接三次握手和释放连接四次握手](http://blog.csdn.net/guyuealian/article/details/52535294)

