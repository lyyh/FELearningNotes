# 直接插入排序
插入排序是一种简单直观的排序算法，它也是基于比较的排序算法。它的工作原理是通过不断扩张有序序列的范围，对于未排序的数据，在已排序中从后向前扫描，找到相应的位置并插入。插入排序在实现上通常采用就地排序，因而空间复杂度为O（1）。在从后向前扫描的过程中，需要反复把已排序元素逐步向后移动，为新元素提供插入空间，因此插入排序的时间复杂度为O（n^2）;
### 算法属性
空间复杂度O(1)  
时间复杂度O(n^2)  
### 算法规则
将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。  

要点：设立哨兵，作为临时存储和判断数组边界之用。

### 算法步骤
1.从第一个元素开始，该元素可以认为已经被排序  
2.取出下一个元素，在已经排序的元素序列中从后向前扫描  
3.如果该元素（已排序）大于新元素，将该元素移到下一位置
4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置  
5.将新元素插入到该位置后  
6.重复步骤2~5  
### 复杂度分析
- 插入排序的最好情况是数组已经有序，此时只需要进行n-1次比较，时间复杂度为O（n）;
- 最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）；
- 平均来说插入排序算法的复杂度为O(n^2)。

# 折半插入（二分插入）
上面的插入排序实现中，为了找到元素的合适的插入位置，我们采用从后到前遍历的顺序查找进行比较，为了减少比较的次数，我们可以换种查找策略：采用二分查找。  
二分法查找法适用于已排序好的序列

### 复杂度分析
我们这个二分查找的算法并不会因为等于某一个值而停止查找，它将查找整个序列直到start<=end条件不满足而得到插入的位置，所以对于长度为n的数组来说，比较次数为log2n ,时间复杂度为O（log2n）。二分插入排序的主要操作为比较+后移赋值，则

1.最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O（n^2）  
2.最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)  
3.平均情况：O（n^2）  
4.空间复杂度上， 二分插入排序也是就地排序算法，它的空间复杂度为O（1）  

